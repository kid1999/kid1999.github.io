<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2019蓝桥杯校赛总结</title>
      <link href="/2019/11/17/2019%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E8%B5%9B/"/>
      <url>/2019/11/17/2019%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="2019蓝桥杯校赛总结"><a href="#2019蓝桥杯校赛总结" class="headerlink" title="2019蓝桥杯校赛总结"></a>2019蓝桥杯校赛总结</h2><h4 id="1-2-计算器计算内存-手动忽略"><a href="#1-2-计算器计算内存-手动忽略" class="headerlink" title="1 - 2 计算器计算内存(手动忽略)"></a>1 - 2 计算器计算内存(手动忽略)</h4><h4 id="3-统计1-2019中带’9’的数字有多少个"><a href="#3-统计1-2019中带’9’的数字有多少个" class="headerlink" title="3.统计1-2019中带’9’的数字有多少个"></a>3.统计1-2019中带’9’的数字有多少个</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class C &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int res = 0;</span><br><span class="line">for(int i=1;i&lt;=2019;i++)&#123;</span><br><span class="line">if(func(String.valueOf(i))) res++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line">public static boolean func(String n) &#123;</span><br><span class="line">for(char c:n.toCharArray())&#123;</span><br><span class="line">if(c == &apos;9&apos;) return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>思路很简单,要么用字符串要么用取模判断是不是含有’9’</li></ul><h4 id="4-统计8-8的图里有多少种走对角线的方式"><a href="#4-统计8-8的图里有多少种走对角线的方式" class="headerlink" title="4.统计8*8的图里有多少种走对角线的方式"></a>4.统计8*8的图里有多少种走对角线的方式</h4><p>这个题有点东西是在给了很多限制，其实最后发现都是没啥用的，加不加也是那么多 (只能往右或者往下走) 直接dfs即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class D &#123;</span><br><span class="line">static int res = 0;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">dfs(0,0,0);</span><br><span class="line">System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line">public static void dfs(int i,int j,int count)&#123;</span><br><span class="line">if(i&lt;0||i&gt;=8||j&lt;0||j&gt;=8||count&gt;14) return;</span><br><span class="line">if(i==7&amp;&amp;j==7&amp;&amp;count==14)&#123;</span><br><span class="line">res++;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">dfs(i+1,j,count+1);</span><br><span class="line">dfs(i,j+1,count+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-和第三题有点类似-只不过是求1-n直接有多少-由不同数字组成的数字"><a href="#5-和第三题有点类似-只不过是求1-n直接有多少-由不同数字组成的数字" class="headerlink" title="5.和第三题有点类似,只不过是求1-n直接有多少(由不同数字组成的数字)"></a>5.和第三题有点类似,只不过是求1-n直接有多少(由不同数字组成的数字)</h4><ul><li>多加一个vis数组判断该数,是否在这个数字里出现过 复杂度应该是(数字的位数*n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class E &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Scanner sc = new Scanner(System.in);</span><br><span class="line">int n = sc.nextInt();</span><br><span class="line">int res = n;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">if(func(i)) res--;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line">public static boolean func(int num)&#123;</span><br><span class="line">boolean[] vis = new boolean[11];//这里有点费空间</span><br><span class="line">while(num != 0)&#123;</span><br><span class="line">int n = num%10;</span><br><span class="line">if(vis[n]) return true;</span><br><span class="line">else vis[n] = true;</span><br><span class="line">num /= 10;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-求最长上升子序列的长度"><a href="#6-求最长上升子序列的长度" class="headerlink" title="6.求最长上升子序列的长度"></a>6.求最长上升子序列的长度</h4><ul><li>直接遍历 (n的时间复杂度) 统计最长的序列长度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class F &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Scanner sc = new Scanner(System.in);</span><br><span class="line">int n = sc.nextInt();</span><br><span class="line">int[] nums = new int[n+1];</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">nums[i] = sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">int max = 1;</span><br><span class="line">int len = 1;</span><br><span class="line">int num = nums[0];</span><br><span class="line">for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">if(num&lt;nums[i]) len++;</span><br><span class="line">else len = 1;</span><br><span class="line">num = nums[i];</span><br><span class="line">if(len &gt; max ) max = len;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(max);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-本来是一道送分题-求逆序对"><a href="#7-本来是一道送分题-求逆序对" class="headerlink" title="7.本来是一道送分题,求逆序对"></a>7.本来是一道送分题,求逆序对</h4><ul><li>写过的题，结果活生生会被自己玩成了丢分题，思路很简单直接两层for暴力也能过，但是使用归并排序理论上是能过10w的测试集的。关键一步没写出来，难受，不想说话…..<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class G &#123;</span><br><span class="line">static int res = 0;</span><br><span class="line">static int[] nums;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Scanner sc = new Scanner(System.in);</span><br><span class="line">int n = sc.nextInt();</span><br><span class="line">nums = new int[n+1];</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">nums[i] = sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">merge_sort(nums,0,n-1);</span><br><span class="line">System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void merge_sort(int[] nums,int l,int r)&#123;</span><br><span class="line">if(l&gt;=r) return;</span><br><span class="line">int mid = l+r&gt;&gt;1;</span><br><span class="line">merge_sort(nums,l,mid);</span><br><span class="line">merge_sort(nums,mid+1,r);</span><br><span class="line">int[] tmp = new int[r-l+1];</span><br><span class="line">int k=0,left=l,right=mid+1;</span><br><span class="line">while(left&lt;=mid &amp;&amp; right&lt;=r)&#123;</span><br><span class="line">if(nums[left]&lt;=nums[right]) tmp[k++] = nums[left++];</span><br><span class="line">else &#123;</span><br><span class="line">tmp[k++] = nums[right++];</span><br><span class="line">res+=mid-left+1;            // 核心: 逆序对 应该是后面的数去前面的路程之和</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while(left&lt;=mid)&#123;</span><br><span class="line">tmp[k++] = nums[left++];</span><br><span class="line">&#125;</span><br><span class="line">while(right&lt;=r) tmp[k++] = nums[right++];</span><br><span class="line">for(int n:tmp) nums[l++] = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-求1-n之间取n个数且满足奇数位大于前一项-偶数位小于前一项"><a href="#8-求1-n之间取n个数且满足奇数位大于前一项-偶数位小于前一项" class="headerlink" title="8.求1-n之间取n个数且满足奇数位大于前一项,偶数位小于前一项"></a>8.求1-n之间取n个数且满足奇数位大于前一项,偶数位小于前一项</h4><ul><li>相当标准的搜索,但是好像拿不了多少分</li><li>思路: 第一个数随便取,后面的按奇偶位分策略搜索<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class H &#123;</span><br><span class="line">static int res = 0;</span><br><span class="line">static int n,m;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Scanner sc = new Scanner(System.in);</span><br><span class="line">m = sc.nextInt();</span><br><span class="line">n = sc.nextInt();</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">dfs(2,i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void dfs(int index,int pre)&#123;</span><br><span class="line">if(index == m+1)&#123;</span><br><span class="line">res++;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if(index % 2 == 0)&#123;</span><br><span class="line">for(int i=1;i&lt;pre;i++)&#123;</span><br><span class="line">dfs(index+1,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">for(int i=pre+1;i&lt;=n;i++)&#123;</span><br><span class="line">dfs(index+1,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="9-加上步长-求最短路径"><a href="#9-加上步长-求最短路径" class="headerlink" title="9.加上步长,求最短路径"></a>9.加上步长,求最短路径</h4><ul><li>也是dfs搜索最短路径,不过是搜索的路线有所限制,必须是满足路径之长小于步长(使用dp数组保存该点的最短路径,用空间换时间)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class I &#123;</span><br><span class="line">static boolean[][] vis;</span><br><span class="line">static int[][] dp;</span><br><span class="line">static int n,m;</span><br><span class="line">static double size; </span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Scanner sc = new Scanner(System.in);</span><br><span class="line">n = sc.nextInt();</span><br><span class="line">m = sc.nextInt();</span><br><span class="line">size = sc.nextDouble();</span><br><span class="line">vis = new boolean[n+1][m+1];</span><br><span class="line">dp = new int[n+1][m+1];</span><br><span class="line">System.out.println(dfs(1,1));</span><br><span class="line">&#125;</span><br><span class="line">public static int dfs(int i,int j)&#123;</span><br><span class="line">if(i==n&amp;&amp;j==m) return 0;</span><br><span class="line">if(dp[i][j] != 0) return dp[i][j];</span><br><span class="line">int min = Integer.MAX_VALUE;</span><br><span class="line">for(int x=0;x&lt;=n-i;x++)&#123;        // 搜索策略</span><br><span class="line">for(int y=0;y&lt;=m-j;y++)&#123;</span><br><span class="line">if(Math.sqrt((x*x) + (y*y)) &gt; size) break;</span><br><span class="line">if(!vis[i+x][j+y]) &#123;</span><br><span class="line">vis[i+x][j+y] = true;</span><br><span class="line">min = Math.min(min, dfs(i+x,j+y));</span><br><span class="line">vis[i+x][j+y] = false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[i][j] = min+1;       // 保存最短路径</span><br><span class="line">return min + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>但是好像还是过不了1000*1000的矩阵</p><h4 id="10-按原顺序输出前n大的数字"><a href="#10-按原顺序输出前n大的数字" class="headerlink" title="10.按原顺序输出前n大的数字"></a>10.按原顺序输出前n大的数字</h4><ul><li>前n大可以直接sort或者用优先队列</li><li>后面按顺序输出,可以用map记录前n大的数据,再回原数组中按位置输出</li><li>使用map可以用key记录数字,value记录出现次数,处理具有重复数据的情况<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class J &#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Scanner sc = new Scanner(System.in);</span><br><span class="line">int n = sc.nextInt();</span><br><span class="line">int m = sc.nextInt();</span><br><span class="line">int[] nums = new int[n+1];</span><br><span class="line">PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;(m);</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">int num = sc.nextInt();</span><br><span class="line">nums[i] = num;</span><br><span class="line">if(q.size() &lt;m) q.add(num);</span><br><span class="line">else if(q.peek() &lt; num)&#123;</span><br><span class="line">q.poll();</span><br><span class="line">q.add(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">int key = q.poll();</span><br><span class="line">if(map.containsKey(key))&#123;</span><br><span class="line">map.put(key,map.get(key)+1);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">map.put(key,1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">if(map.containsKey(nums[i]))&#123;</span><br><span class="line">System.out.print(nums[i] + &quot; &quot;);</span><br><span class="line">if(map.get(nums[i]) == 1) map.remove(nums[i]);</span><br><span class="line">else map.put(nums[i], map.get(nums[i])-1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>O(nlogn)的复杂度,应该能过,只是最后太着急,忘了加上判断,value为0时删除该元素….</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p> DFS用的很多，但是剪枝没写好，只能拿部分分。<br> 失误太多，会的没写出来，反而浪费大把时间。希望能过校赛，给个补救的机会。。。。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>排序模板</title>
      <link href="/2019/11/16/%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF/"/>
      <url>/2019/11/16/%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul><li>利用分治，选择一个标兵使左右区间分别满足&lt;=和&gt;=标兵，递归子区间直到区间长度为1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void quick_sort(int[] nums, int l, int r) &#123;</span><br><span class="line">if(l&gt;=r) return;</span><br><span class="line">int m = nums[l+r&gt;&gt;1],left = l-1,right = r+1;  //注意此处的标兵取值 必须与下面递归的标兵相反 l - right</span><br><span class="line">while (left&lt;right)&#123;</span><br><span class="line">do left++; while (nums[left] &lt; m);</span><br><span class="line">do right--; while (nums[right] &gt; m);</span><br><span class="line">if(left&lt;right) &#123;</span><br><span class="line">int tmp = nums[left];</span><br><span class="line">nums[left] = nums[right];</span><br><span class="line">nums[right] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">quick_sort(nums,l,right);</span><br><span class="line">quick_sort(nums,right+1, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>持续优化：1.类似荷兰旗问题，当所求值与标兵相同时 不参与下一次递归<br>  2.随机标兵 表现会比固定标兵的效果好</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ul><li>也是分治，先递归，再合并。每次递归二分直到区间长度为1，然后和并返回有序数组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void merge_sort(int[] nums,int l,int r)&#123;</span><br><span class="line">    if(l&gt;=r) return;</span><br><span class="line">    int mid = l+r&gt;&gt;1;</span><br><span class="line">    merge_sort(nums,l,mid);</span><br><span class="line">    merge_sort(nums,mid+1,r);</span><br><span class="line">    int[] tmp = new int[r-l+1];</span><br><span class="line">    int k=0,left=l,right=mid+1;</span><br><span class="line">    while(left&lt;=mid &amp;&amp; right&lt;=r)&#123;</span><br><span class="line">        if(nums[left]&lt;nums[right]) tmp[k++] = nums[left++];</span><br><span class="line">        else tmp[k++] = nums[right++];</span><br><span class="line">    &#125;</span><br><span class="line">    while(left&lt;=mid) tmp[k++] = nums[left++];</span><br><span class="line">    while(right&lt;=r) tmp[k++] = nums[right++];</span><br><span class="line">    for(int n:tmp) nums[l++] = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快排重在切分区间，归并重在合并区间"><a href="#快排重在切分区间，归并重在合并区间" class="headerlink" title="快排重在切分区间，归并重在合并区间"></a>快排重在切分区间，归并重在合并区间</h4><h2 id="java中的复合排序"><a href="#java中的复合排序" class="headerlink" title="java中的复合排序"></a>java中的复合排序</h2><ul><li>对新建的结构体使用继承 Comparable接口 实习排序对比</li><li>对于普通的对比，使用 new Comparator类</li><li>对于复合对比 使用多层if-else嵌套</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.List;</span><br><span class="line">// 对结构体排序</span><br><span class="line">class Node implements Comparable&lt;Node&gt;&#123;</span><br><span class="line">int x;</span><br><span class="line">int y;</span><br><span class="line">public Node(int x, int y) &#123;</span><br><span class="line">this.x = x;</span><br><span class="line">this.y = y;</span><br><span class="line">&#125;</span><br><span class="line">// 先按 x 排序 再按 y排序</span><br><span class="line">@Override</span><br><span class="line">public int compareTo(Node other) &#123;</span><br><span class="line">if(other.x &gt; this.x) return 1;</span><br><span class="line">else if(other.x &lt; this.x) return -1;</span><br><span class="line">else &#123;</span><br><span class="line">return other.y - this.y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class NodeSort &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">List&lt;Node&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.sort(new Comparator&lt;Node&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public int compare(Node o1, Node o2) &#123;</span><br><span class="line">return o1.x-o2.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java中的优先队列（堆排序）"><a href="#java中的优先队列（堆排序）" class="headerlink" title="java中的优先队列（堆排序）"></a>java中的优先队列（堆排序）</h2><ul><li>堆排序默认维护n大小的最值（默认最大值 小顶堆）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">public class heapSort &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    int[] arr = &#123;1,5,3,2,7,6,4,9,8&#125;;</span><br><span class="line">    int k = 3;      // 队的size</span><br><span class="line">    PriorityQueue&lt;Integer&gt; q1 = new PriorityQueue&lt;&gt;(k);   // 维护小顶堆</span><br><span class="line">    PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;(k, new Comparator&lt;Integer&gt;() &#123;   // 维护大顶堆</span><br><span class="line">      @Override</span><br><span class="line">      public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">        return o2-o1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    for (int i = 0; i &lt;9 ; i++) &#123;</span><br><span class="line">      if(q.size() &lt; k) q.add(arr[i]);</span><br><span class="line">      else if(arr[i] &lt; q.peek())&#123;</span><br><span class="line">        q.poll();</span><br><span class="line">        q.add(arr[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt;k ; i++) &#123;</span><br><span class="line">      System.out.println(q.poll());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
