<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go初试 六</title>
      <link href="/2019/11/24/Go%E5%88%9D%E8%AF%95%E5%85%AD/"/>
      <url>/2019/11/24/Go%E5%88%9D%E8%AF%95%E5%85%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言入门尝试-六"><a href="#Go语言入门尝试-六" class="headerlink" title="Go语言入门尝试  六"></a>Go语言入门尝试  六</h1><ul><li>Go（又称 Golang）是 Google 的 Robert Griesemer，Rob Pike 及 Ken Thompson 开发的一种静态强类型、编译型语言。Go 语言语法与 C 相近，但功能上有：内存安全，GC（垃圾回收），结构形态及 CSP-style 并发计算。</li></ul><h2 id="1-Go语言的协程机制"><a href="#1-Go语言的协程机制" class="headerlink" title="1.Go语言的协程机制"></a>1.Go语言的协程机制</h2><ul><li>协程细化于线程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package ch16</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;testing&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func TestGroutine(t *testing.T)  &#123;</span><br><span class="line">for i:=0;i&lt;10;i++&#123;</span><br><span class="line">go func(i int) &#123;//go 启动一个协程</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;(i)</span><br><span class="line">time.Sleep(time.Millisecond*50)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-通过共享内存实现协程通讯"><a href="#2-通过共享内存实现协程通讯" class="headerlink" title="2. 通过共享内存实现协程通讯"></a>2. 通过共享内存实现协程通讯</h2><ul><li>通过同享资源 上锁，等待的方式 实现协程的有序执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package ch17</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">&quot;testing&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">共享内存的并发机制</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 线程不安全的</span><br><span class="line">func TestCounterThread(t *testing.T)  &#123;</span><br><span class="line">counter := 0// 存在竞争</span><br><span class="line">for i:=0;i&lt;5000;i++&#123;</span><br><span class="line">go func() &#123;</span><br><span class="line">counter++</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">t.Log(&quot;counter = &quot;,counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 加锁线程安全</span><br><span class="line">func TestCounterThreadSafe(t *testing.T)  &#123;</span><br><span class="line">var mut sync.Mutex</span><br><span class="line">counter := 0// 存在竞争</span><br><span class="line">for i:=0;i&lt;5000;i++&#123;</span><br><span class="line">go func() &#123;</span><br><span class="line">defer func() &#123;mut.Unlock()&#125;()//进程错误时释放资源</span><br><span class="line">mut.Lock()// 加锁</span><br><span class="line">counter++</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)// 等待内部线程执行完</span><br><span class="line">t.Log(&quot;counter = &quot;,counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 等待子线程运行完  类似 join</span><br><span class="line">func TestCounterThreadWaitGroup(t *testing.T)  &#123;</span><br><span class="line">var mut sync.Mutex</span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line">counter := 0// 存在竞争</span><br><span class="line">for i:=0;i&lt;5000;i++&#123;</span><br><span class="line">wg.Add(1)// 开始等待</span><br><span class="line">go func() &#123;</span><br><span class="line">defer func() &#123;mut.Unlock()&#125;()//进程错误时释放资源</span><br><span class="line">mut.Lock()// 加锁</span><br><span class="line">counter++</span><br><span class="line">wg.Done()//等待结束</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()//等待</span><br><span class="line">t.Log(&quot;counter = &quot;,counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-使用channel的方式实现协程的通讯"><a href="#3-使用channel的方式实现协程的通讯" class="headerlink" title="3.使用channel的方式实现协程的通讯"></a>3.使用channel的方式实现协程的通讯</h2><ul><li>channel 分两种队列不等待 和 牵手等待 （channel的容量决定）</li><li>此次模拟一个生产消费模型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package ch17</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;testing&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//  串行 运行两个任务</span><br><span class="line">func service() string  &#123;</span><br><span class="line">time.Sleep(time.Millisecond *50)</span><br><span class="line">return &quot;Done&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//并行运行两个协程  通过 channel  通讯</span><br><span class="line">func AsyncService() chan string &#123;</span><br><span class="line">rerch := make(chan string,1)// buffer channel 消息队列</span><br><span class="line">go func() &#123;</span><br><span class="line">ret := service()</span><br><span class="line">fmt.Println(&quot;returned result.&quot;)</span><br><span class="line">rerch &lt;- ret// 如果是普通channel service发送数据后会等待other拿走数据</span><br><span class="line">fmt.Println(&quot;service exited.&quot;)</span><br><span class="line">&#125;()</span><br><span class="line">return rerch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 其他任务</span><br><span class="line">func otherTask()  &#123;</span><br><span class="line">fmt.Println(&quot;work on someting else&quot;)</span><br><span class="line">time.Sleep(time.Millisecond *100)</span><br><span class="line">fmt.Println(&quot;Task is Done.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestService(t *testing.T)  &#123;</span><br><span class="line">//fmt.Println(service())</span><br><span class="line">retch := AsyncService()</span><br><span class="line">otherTask()</span><br><span class="line">fmt.Println(&lt;-retch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-select-语句"><a href="#4-select-语句" class="headerlink" title="4.select 语句"></a>4.select 语句</h2><ul><li><p>select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。</p></li><li><p>select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package ch18</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;testing&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func service() string  &#123;</span><br><span class="line">time.Sleep(time.Millisecond *500)</span><br><span class="line">return &quot;Done&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func AsyncService() chan string &#123;</span><br><span class="line">rerch := make(chan string,1)// buffer channel 消息队列</span><br><span class="line">go func() &#123;</span><br><span class="line">ret := service()</span><br><span class="line">fmt.Println(&quot;returned result.&quot;)</span><br><span class="line">rerch &lt;- ret// 如果是普通channel service发送数据后会等待other拿走数据</span><br><span class="line">fmt.Println(&quot;service exited.&quot;)</span><br><span class="line">&#125;()</span><br><span class="line">return rerch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func TestService(t *testing.T)  &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case ret := &lt;-AsyncService():</span><br><span class="line">t.Log(ret)</span><br><span class="line">case &lt;-time.After(time.Millisecond *100):// 超时直接 gg</span><br><span class="line">t.Error(&quot;time out&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-channel-的退出"><a href="#5-channel-的退出" class="headerlink" title="5.channel 的退出"></a>5.channel 的退出</h2><ul><li>生产者使用 close 关闭协程</li><li>当 协程结束时，使用 WaitGroup Done 通知消费者协程关闭</li><li>主进程等待所有Done后结束</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package ch19</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 生产者</span><br><span class="line">func dataProducer(ch chan int,wg *sync.WaitGroup)  &#123;</span><br><span class="line">go func() &#123;</span><br><span class="line">for i:=0;i&lt;10 ;i++  &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">close(ch)// 关闭 chanel</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 消费者</span><br><span class="line">func dataReceiver(ch chan int,wg *sync.WaitGroup)&#123;</span><br><span class="line">go func() &#123;</span><br><span class="line">for&#123;</span><br><span class="line">if data,ok := &lt;-ch;ok&#123;// 在channel时 退出</span><br><span class="line">fmt.Println(data)</span><br><span class="line">&#125;else &#123;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestCloseChannel(t *testing.T)  &#123;</span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line">ch := make(chan int)</span><br><span class="line">wg.Add(1)</span><br><span class="line">dataProducer(ch,&amp;wg)</span><br><span class="line">wg.Add(1)</span><br><span class="line">dataReceiver(ch,&amp;wg)</span><br><span class="line">wg.Wait()//等待两个协程结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GoLang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 并发编程 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go初试五</title>
      <link href="/2019/11/24/Go%E5%88%9D%E8%AF%95%E4%BA%94/"/>
      <url>/2019/11/24/Go%E5%88%9D%E8%AF%95%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<hr><p>title: Go初试 五<br>date: 2019-11-24 23:27:26<br>tags: “Go”<br>categories: “GoLang”</p><hr><h1 id="Go语言入门尝试-五"><a href="#Go语言入门尝试-五" class="headerlink" title="Go语言入门尝试  五"></a>Go语言入门尝试  五</h1><ul><li>Go（又称 Golang）是 Google 的 Robert Griesemer，Rob Pike 及 Ken Thompson 开发的一种静态强类型、编译型语言。Go 语言语法与 C 相近，但功能上有：内存安全，GC（垃圾回收），结构形态及 CSP-style 并发计算。</li></ul><h2 id="1-Go语言中本地包的构建和使用"><a href="#1-Go语言中本地包的构建和使用" class="headerlink" title="1. Go语言中本地包的构建和使用"></a>1. Go语言中本地包的构建和使用</h2><ul><li><ol><li>生成一个斐波那契数列函数的包  ch15/series/…go<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package series</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;errors&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 初始化函数</span><br><span class="line">func init()  &#123;</span><br><span class="line">fmt.Println(&quot;init...&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func GetFib(n int) ([]int,error) &#123;</span><br><span class="line">if n &lt; 2 || n &gt; 100&#123;</span><br><span class="line">return nil,errors.New(&quot;n should be in [2,100]&quot;)</span><br><span class="line">&#125;</span><br><span class="line">res := []int&#123;1,1&#125;</span><br><span class="line">for i:=2;i&lt;n;i++&#123;</span><br><span class="line">res = append(res,res[i-1]+res[i-2])</span><br><span class="line">&#125;</span><br><span class="line">return res,nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>2.使用刚刚声明的包  ch15/client/…go</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package client</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;ch15/series&quot;       // 引入</span><br><span class="line">&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 调用 自定义的包</span><br><span class="line">func TestPackage(t *testing.T)  &#123;</span><br><span class="line">t.Log(series.GetFib(10))// 包内方法必须是大写开头 不然无法识别</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意有几点：</p></li><li><p>包路径，包内方法名必须大写开头…</p></li></ul><h2 id="2-使用网上的包"><a href="#2-使用网上的包" class="headerlink" title="2.使用网上的包"></a>2.使用网上的包</h2><ul><li>远程的包，大多托管于 github </li><li>使用命令 go get github.com/作者/项目名</li><li>例如： go get github.com/emirpasic/Gods<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package remote_package</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;github.com/emirpasic/Gods/lists/arraylist&quot;</span><br><span class="line">&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">包管理 软件：</span><br><span class="line">dep</span><br><span class="line">golide</span><br><span class="line">go module</span><br><span class="line">。。。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">func TestRemotePackage(t *testing.T)  &#123;</span><br><span class="line">list := arraylist.New()</span><br><span class="line">a := &apos;a&apos;</span><br><span class="line">for i:=0;i&lt;26;i++&#123;</span><br><span class="line">list.Add(string(a))</span><br><span class="line">a++</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go初试 四</title>
      <link href="/2019/11/24/Go%E5%88%9D%E8%AF%95%E5%9B%9B/"/>
      <url>/2019/11/24/Go%E5%88%9D%E8%AF%95%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="Go语言入门尝试-四"><a href="#Go语言入门尝试-四" class="headerlink" title="Go语言入门尝试  四"></a>Go语言入门尝试  四</h1><ul><li>Go（又称 Golang）是 Google 的 Robert Griesemer，Rob Pike 及 Ken Thompson 开发的一种静态强类型、编译型语言。Go 语言语法与 C 相近，但功能上有：内存安全，GC（垃圾回收），结构形态及 CSP-style 并发计算。</li></ul><h2 id="1-Go的继承"><a href="#1-Go的继承" class="headerlink" title="1. Go的继承"></a>1. Go的继承</h2><ul><li>Go 的继承是不完整的</li><li>父类无法访问子类的数据和方法 ，只能全部重写 获得新的方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package ch12</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">go的继承不能叫做完整的继承：</span><br><span class="line">1. 父类无法访问子类的数据和方法  无多态</span><br><span class="line">2. 只能全部重写 获得新的方法</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// pet 类</span><br><span class="line">type Pet struct &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Pet) Speak()&#123;</span><br><span class="line">fmt.Print(&quot;....&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Pet) SpeakTo(host string)&#123;</span><br><span class="line">p.Speak()</span><br><span class="line">fmt.Println(&quot; &quot;,host)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// dog 类  继承 pet</span><br><span class="line">/*</span><br><span class="line">type Dog struct &#123;</span><br><span class="line">p *Pet</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (d *Dog) Speak()&#123;</span><br><span class="line">d.p.Speak()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (d *Dog) SpeakTo(host string)&#123;</span><br><span class="line">d.p.SpeakTo(host)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 子类继承父类的简单写法：</span><br><span class="line">type Dog struct &#123;</span><br><span class="line">Pet</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// test</span><br><span class="line">func TestDog(t *testing.T)  &#123;</span><br><span class="line">dog := new(Dog)</span><br><span class="line">dog.SpeakTo(&quot;kid&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-空接口"><a href="#2-空接口" class="headerlink" title="2.空接口"></a>2.空接口</h2><ul><li>Go 允许空接口，但是同时可可以判断接口的type<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package ch13</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Testfn(p interface&#123;&#125;)&#123;</span><br><span class="line">switch p.(type) &#123;</span><br><span class="line">case int:</span><br><span class="line">fmt.Println(&quot;int &quot;,p)</span><br><span class="line">case string:</span><br><span class="line">fmt.Println(&quot;string &quot;,p)</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;Unknow type.&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 空接口</span><br><span class="line">func TestEmptyAssertion(t *testing.T)  &#123;</span><br><span class="line">Testfn(10)</span><br><span class="line">Testfn(&quot;10&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-通过接口实现多态"><a href="#3-通过接口实现多态" class="headerlink" title="3.通过接口实现多态"></a>3.通过接口实现多态</h2><ul><li>标准步骤：定义接口，父类，子类，抽象方法调用父类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package ch13</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Code string</span><br><span class="line">/*</span><br><span class="line">通过 接口实现 多态</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 定义接口</span><br><span class="line">type Programmer interface &#123;</span><br><span class="line">HelloWrold() Code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type GOPaogrammer struct &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *GOPaogrammer) HelloWrold() Code&#123;</span><br><span class="line">return &quot;Go&apos;s code&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type JavaProgrammer struct &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *JavaProgrammer) HelloWrold() Code &#123;</span><br><span class="line">return &quot;Java&apos;s code&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 一个抽象方法</span><br><span class="line">func aProgram(p Programmer)&#123;</span><br><span class="line">fmt.Printf(&quot;%T  %v\n&quot;,p,p.HelloWrold())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func Test(t *testing.T)&#123;</span><br><span class="line">goProg := &amp;GOPaogrammer&#123;&#125;// 新建一个对象返回的实际上一个指针</span><br><span class="line">javaProg := new(JavaProgrammer)</span><br><span class="line">aProgram(goProg)</span><br><span class="line">aProgram(javaProg)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-错误处理"><a href="#4-错误处理" class="headerlink" title="4. 错误处理"></a>4. 错误处理</h2><ul><li>核心： 及早失败，早处理</li><li>使用多返回值的特点把错误信息带出函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package ch14</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;errors&quot;</span><br><span class="line">&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func GetFib(n int) ([]int,error) &#123;</span><br><span class="line">if n &lt; 2 || n &gt; 100&#123;</span><br><span class="line">return nil,errors.New(&quot;n should be in [2,100]&quot;)</span><br><span class="line">&#125;</span><br><span class="line">res := []int&#123;1,1&#125;</span><br><span class="line">for i:=2;i&lt;n;i++&#123;</span><br><span class="line">res = append(res,res[i-1]+res[i-2])</span><br><span class="line">&#125;</span><br><span class="line">return res,nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 核心： 及早失败</span><br><span class="line">1.Go 的错误机制： errors.New（）</span><br><span class="line">2.使用多返回值 带出错误</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">func TestFunc(t *testing.T)  &#123;</span><br><span class="line">if v,err:=GetFib(-10);err!=nil&#123;</span><br><span class="line">t.Error(err)</span><br><span class="line">&#125;else &#123;</span><br><span class="line">t.Log(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-错误恢复"><a href="#5-错误恢复" class="headerlink" title="5. 错误恢复"></a>5. 错误恢复</h2><ul><li>使用recover恢复是很危险的，容易造成僵尸进程</li><li>中断的三种方式的 不同点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package ch14</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;errors&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// recover 恢复错误  很危险的</span><br><span class="line">func TestPanicVxExit(t *testing.T)  &#123;</span><br><span class="line">defer func() &#123;</span><br><span class="line">if err:= recover();err !=nil&#123;</span><br><span class="line">fmt.Println(&quot;recovered from &quot;,err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(&quot;start&quot;)</span><br><span class="line">panic(errors.New(&quot;someting error!&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">panic抛出异常退出</span><br><span class="line">exit 异常退出</span><br><span class="line">recover 恢复出错前的状态</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> GoLang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go初试 三</title>
      <link href="/2019/11/24/Go%E5%88%9D%E8%AF%95%E4%B8%89/"/>
      <url>/2019/11/24/Go%E5%88%9D%E8%AF%95%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言入门尝试-三"><a href="#Go语言入门尝试-三" class="headerlink" title="Go语言入门尝试  三"></a>Go语言入门尝试  三</h1><ul><li>Go（又称 Golang）是 Google 的 Robert Griesemer，Rob Pike 及 Ken Thompson 开发的一种静态强类型、编译型语言。Go 语言语法与 C 相近，但功能上有：内存安全，GC（垃圾回收），结构形态及 CSP-style 并发计算。</li></ul><h2 id="1-func-方法"><a href="#1-func-方法" class="headerlink" title="1.func 方法"></a>1.func 方法</h2><ul><li>方法是go里面的一等公民</li><li>方法可以返回方法 类似包装器</li><li>多返回</li><li>多参数</li><li>defer 最后执行 类似finally</li><li>func 都是赋值传递参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">package ch10</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;math/rand&quot;</span><br><span class="line">&quot;testing&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 类似包装器： 输入func 输出func</span><br><span class="line">func timeSpent(testFunc func(op int) int) func(op int) int  &#123;</span><br><span class="line">return func(n int) int &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line">ret := testFunc(n)</span><br><span class="line">fmt.Print(&quot;time spent:&quot;,time.Since(start).Seconds())</span><br><span class="line">return ret</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func slowFun(op int) int&#123;</span><br><span class="line">time.Sleep(time.Second*1)</span><br><span class="line">return op</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestSlowFun(t *testing.T)&#123;</span><br><span class="line">tsSF := timeSpent(slowFun)</span><br><span class="line">t.Log(tsSF(10))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 多返回的方法</span><br><span class="line">func returnMultiValues() (int,int)&#123;</span><br><span class="line">return rand.Intn(10),rand.Intn(25)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestFn(t *testing.T)  &#123;</span><br><span class="line">a,b := returnMultiValues()</span><br><span class="line">t.Log(a,b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 多参数方法</span><br><span class="line">func Sum(ops ...int) int&#123;</span><br><span class="line">res:=0</span><br><span class="line">for _,op := range ops&#123;</span><br><span class="line">res += op</span><br><span class="line">&#125;</span><br><span class="line">return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestVarparam(t *testing.T)&#123;</span><br><span class="line">t.Log(Sum(1,2,3,4,5))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 最后执行函数 类似finally</span><br><span class="line">func Clear()&#123;</span><br><span class="line">fmt.Println(&quot;clear resource.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestDefer(t *testing.T)&#123;</span><br><span class="line">defer Clear()// 最后执行</span><br><span class="line">fmt.Println(&quot;start test.&quot;)</span><br><span class="line">panic(&quot;err&quot;) // 异常退出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-类型预定义"><a href="#2-类型预定义" class="headerlink" title="2. 类型预定义"></a>2. 类型预定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package ch11</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;testing&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 使用类型预定义 简化</span><br><span class="line">type IntConv func(op int) int</span><br><span class="line"></span><br><span class="line">func timeSpent(testFunc IntConv) IntConv  &#123;</span><br><span class="line">return func(n int) int &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line">ret := testFunc(n)</span><br><span class="line">fmt.Print(&quot;time spent:&quot;,time.Since(start).Seconds())</span><br><span class="line">return ret</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func slowFun(op int) int&#123;</span><br><span class="line">time.Sleep(time.Second*1)</span><br><span class="line">return op</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestSlowFun(t *testing.T)&#123;</span><br><span class="line">tsSF := timeSpent(slowFun)</span><br><span class="line">t.Log(tsSF(10))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-类（结构体）"><a href="#3-类（结构体）" class="headerlink" title="3. 类（结构体）"></a>3. 类（结构体）</h2><ul><li>go 的类 类似于 结构体 + 包含该结构体指针的func</li><li>2种定义类方法的方式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package ch11</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;testing&quot;</span><br><span class="line">&quot;unsafe&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义结构体</span><br><span class="line">type Employee struct &#123;</span><br><span class="line">Id string</span><br><span class="line">Name string</span><br><span class="line">Age int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义类方法</span><br><span class="line"></span><br><span class="line">// 1. 使用 对象复制传递： 实例成员会进行值复制</span><br><span class="line">func (e Employee) String() string  &#123;</span><br><span class="line">fmt.Printf(&quot;address is %x\n&quot;,unsafe.Pointer(&amp;e.Name))// 输出 name的地址</span><br><span class="line">return fmt.Sprintf(&quot;Id:%s-name:%s-age:%d&quot;,e.Id,e.Name,e.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 使用 指针复制传递： 实例成员不会进行值复制</span><br><span class="line">func (e *Employee) toString() string  &#123;</span><br><span class="line">fmt.Printf(&quot;address is %x\n&quot;,unsafe.Pointer(&amp;e.Name))// 输出 name的地址</span><br><span class="line">return fmt.Sprintf(&quot;Id:%s-name:%s-age:%d&quot;,e.Id,e.Name,e.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestStruct(t *testing.T)&#123;</span><br><span class="line">e := Employee&#123;&quot;0&quot;,&quot;kid&quot;,20&#125;</span><br><span class="line">t.Log(e.String())</span><br><span class="line">t.Logf(&quot;%T&quot;,e)//等得到的是对象</span><br><span class="line"></span><br><span class="line">e1 := &amp;Employee&#123;&quot;0&quot;,&quot;kid&quot;,25&#125;</span><br><span class="line">t.Log(e1.toString())</span><br><span class="line">t.Logf(&quot;%T&quot;,e1)//等得到的是对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-接口"><a href="#4-接口" class="headerlink" title="4.接口"></a>4.接口</h2><ul><li>Go 无继承 只有接口</li><li>go 是 鸭子类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package ch11</span><br><span class="line"></span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">type Progarmmer interface &#123;</span><br><span class="line">WriteHelloWorld() string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Goparogrammer struct &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (g *Goparogrammer) WriteHelloWorld() string&#123;</span><br><span class="line">return &quot;fmt.Println(\&quot;Hello world\&quot;)&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// go 接口没有依赖关系 是鸭子类型</span><br><span class="line">func TestClient(t *testing.T)&#123;</span><br><span class="line">var p Progarmmer</span><br><span class="line">p = new (Goparogrammer)</span><br><span class="line">t.Log(p.WriteHelloWorld())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GoLang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go初试 二</title>
      <link href="/2019/11/24/Go%E5%88%9D%E8%AF%95%E4%BA%8C/"/>
      <url>/2019/11/24/Go%E5%88%9D%E8%AF%95%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言入门尝试-二"><a href="#Go语言入门尝试-二" class="headerlink" title="Go语言入门尝试  二"></a>Go语言入门尝试  二</h1><ul><li>Go（又称 Golang）是 Google 的 Robert Griesemer，Rob Pike 及 Ken Thompson 开发的一种静态强类型、编译型语言。Go 语言语法与 C 相近，但功能上有：内存安全，GC（垃圾回收），结构形态及 CSP-style 并发计算。</li></ul><h2 id="1-Array数组"><a href="#1-Array数组" class="headerlink" title="1.Array数组"></a>1.Array数组</h2><ul><li>数组的三种初始化方式</li><li>数组的遍历方式</li><li>数组的切片<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package ch6</span><br><span class="line"></span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">func TestArrayInit(t *testing.T)&#123;</span><br><span class="line">// 默认初始化为0</span><br><span class="line">var arr [3]int</span><br><span class="line">t.Log(arr[1],arr[2])</span><br><span class="line">// 初始化赋值</span><br><span class="line">arr2 := [3]int&#123;1,2,3&#125;</span><br><span class="line">t.Log(arr2)</span><br><span class="line">// 初始化自定义大小</span><br><span class="line">arr3 :=[...]int&#123;1,2,3&#125;</span><br><span class="line">t.Log(arr3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 数组的遍历</span><br><span class="line">func TestArrayTravel(t *testing.T)  &#123;</span><br><span class="line">arr4:=[...]int&#123;1,2,3,4,5&#125;</span><br><span class="line">// 普通写法</span><br><span class="line">for i:=0;i&lt;len(arr4) ;i++  &#123;</span><br><span class="line">t.Log(arr4[i])</span><br><span class="line">&#125;</span><br><span class="line">// for each</span><br><span class="line">for _,e := range arr4&#123;</span><br><span class="line">t.Log(e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 数组的切片  [包含，不包含]</span><br><span class="line">func TestArraySection(t *testing.T)&#123;</span><br><span class="line">arr5:= [...]int&#123;1,2,3,4&#125;;</span><br><span class="line">arr5_sec := arr5[:3]</span><br><span class="line">t.Log(arr5,arr5_sec)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-切片"><a href="#2-切片" class="headerlink" title="2.切片"></a>2.切片</h2><ul><li>切片是种数据结构：（起点，当前长度，总容量）</li><li>切片的容量增长规律为 2^n 类似List</li><li>切片的初始化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package ch6</span><br><span class="line"></span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">// 切片</span><br><span class="line">func TestSlice(t *testing.T)  &#123;</span><br><span class="line">var s0 []int</span><br><span class="line">t.Log(len(s0),cap(s0))</span><br><span class="line">s0 = append(s0, 1)</span><br><span class="line">t.Log(len(s0),cap(s0))// 可访问序列的长度和容量</span><br><span class="line"></span><br><span class="line">s1:=[]int&#123;1,2,3,4&#125;// 生成一个切片</span><br><span class="line">t.Log(len(s1),cap(s1))</span><br><span class="line"></span><br><span class="line">s2:=make([]int,3,5)// 生成长度为3容量为5的切片</span><br><span class="line">t.Log(len(s2),cap(s2))</span><br><span class="line">t.Log(s2[0],s2[1],s2[2])</span><br><span class="line"></span><br><span class="line">// 往len后追加</span><br><span class="line">s2 = append(s2, 1)</span><br><span class="line">t.Log(s2[0],s2[1],s2[2],s2[3])</span><br><span class="line">t.Log(len(s2),cap(s2))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 切片容量和长度的增长规律  容量按2^n增长</span><br><span class="line">func TestSliceGrowing(t *testing.T)  &#123;</span><br><span class="line">s:=[]int&#123;&#125;</span><br><span class="line">for i:=0;i&lt;10;i++ &#123;</span><br><span class="line">s = append(s, i)</span><br><span class="line">t.Log(len(s),cap(s))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 切片的数据结构</span><br><span class="line">func TestSliceShareMemory(t *testing.T)&#123;</span><br><span class="line">year := []string&#123;&quot;Jan&quot;,&quot;Feb&quot;,&quot;Mar&quot;,&quot;Apr&quot;,&quot;May&quot;,&quot;Jun&quot;,&quot;Jul&quot;,&quot;Aug&quot;,&quot;Sep&quot;,&quot;Oct&quot;,&quot;Nov&quot;,&quot;Dec&quot;&#125;</span><br><span class="line">Q2 := year[3:6]</span><br><span class="line">t.Log(Q2,len(Q2),cap(Q2))// 长度为3 容量为9</span><br><span class="line"></span><br><span class="line">summer:=year[5:8]</span><br><span class="line">summer[0] = &quot;Unknow&quot;// 整个数组都会被影响</span><br><span class="line">t.Log(year)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-map-k-v键值对"><a href="#3-map-k-v键值对" class="headerlink" title="3.map k-v键值对"></a>3.map k-v键值对</h2><ul><li>map的初始化</li><li>对于不存的元素 返回 状态</li><li>遍历</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package ch7</span><br><span class="line"></span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">// map 的初始化</span><br><span class="line">func TestInitMap(t *testing.T)  &#123;</span><br><span class="line">m1 := map[int]int&#123;1:1,2:4,3:9&#125;</span><br><span class="line">t.Log(m1[2])</span><br><span class="line">t.Log(&quot;len m1&quot;,len(m1))</span><br><span class="line"></span><br><span class="line">m2 := map[int]int&#123;&#125;</span><br><span class="line">m2[4] = 16</span><br><span class="line">t.Log(&quot;len m2&quot;,len(m2))</span><br><span class="line"></span><br><span class="line">m3:= make(map[int]int,10)// 初始化map容量长度</span><br><span class="line">t.Log(&quot;len m3&quot;,len(m3))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对比 value = 0 和 元素不存在</span><br><span class="line">func TestAccessNotExistKey(t *testing.T)&#123;</span><br><span class="line">m1 := map[int]int&#123;&#125;// 初始化都为0</span><br><span class="line">t.Log(m1[1])</span><br><span class="line">m1[2] = 0</span><br><span class="line">t.Log(m1[2])</span><br><span class="line"></span><br><span class="line">if v,ok := m1[3];ok&#123;//如果key不存在除了返回value=0，还会返回一个状态为false</span><br><span class="line">t.Log(&quot;key 3&apos;s value is &quot;,v)</span><br><span class="line">&#125;else &#123;</span><br><span class="line">t.Log(&quot;key 3 is not existing.&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历 map</span><br><span class="line">func TestTravelMap(t *testing.T)  &#123;</span><br><span class="line">m1 := map[int]int&#123;1:1,2:4,3:9&#125;</span><br><span class="line">for k,v := range m1 &#123;</span><br><span class="line">t.Log(k,v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-map-的拓展"><a href="#4-map-的拓展" class="headerlink" title="4.map 的拓展"></a>4.map 的拓展</h2><ul><li>map存储func</li><li>map实现set<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package ch8</span><br><span class="line"></span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">// 将方法作为map的value</span><br><span class="line">func TestMapWithFubValue(t *testing.T)  &#123;</span><br><span class="line">m := map[int] func(op int)int &#123;&#125;</span><br><span class="line">m[1] = func(op int) int &#123;return op&#125;</span><br><span class="line">m[2] = func(op int) int &#123;return op*op&#125;</span><br><span class="line">m[3] = func(op int) int &#123;return op*op*op&#125;</span><br><span class="line"></span><br><span class="line">t.Log(m[1](2),m[2](2),m[3](2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用map 实现 set</span><br><span class="line">func TestMapForSet(t *testing.T)&#123;</span><br><span class="line">mySet := map[int]bool&#123;&#125;</span><br><span class="line">mySet[1] = true</span><br><span class="line">n:=1</span><br><span class="line">if mySet[n]&#123;</span><br><span class="line">t.Log(n,&quot; is exist&quot;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">t.Log(n,&quot;is not exist.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mySet[3] = true</span><br><span class="line">t.Log(len(mySet))</span><br><span class="line">delete(mySet,1)</span><br><span class="line">n=1</span><br><span class="line">if mySet[n]&#123;</span><br><span class="line">t.Log(n,&quot; is exist&quot;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">t.Log(n,&quot;is not exist.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-string"><a href="#5-string" class="headerlink" title="5.string"></a>5.string</h2><ul><li>string 默认 utf-8编码</li><li>遍历</li><li>strings的函数</li><li>strconv的函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package ch9</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;strconv&quot;</span><br><span class="line">&quot;strings&quot;</span><br><span class="line">&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 字符集 和 字符编码</span><br><span class="line">func TestString(t *testing.T)&#123;</span><br><span class="line">var s string</span><br><span class="line">t.Log(s)</span><br><span class="line">t.Log(len(s))</span><br><span class="line"></span><br><span class="line">s = &quot;\xE4\xB8\xA5&quot;</span><br><span class="line">t.Log(s)</span><br><span class="line">s = &quot;中&quot;</span><br><span class="line">t.Log(len(s))</span><br><span class="line"></span><br><span class="line">c := []rune(s)</span><br><span class="line">t.Logf(&quot;中 unicode %x&quot;,c[0])// 字符编码</span><br><span class="line">t.Logf(&quot;中 UTF8 %x&quot;,s)// 字符编码的具体实现</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 字符串的遍历</span><br><span class="line">func TestStringRange(t *testing.T)&#123;</span><br><span class="line">s:=&quot;中华人民共和国&quot;</span><br><span class="line">for _,value := range s&#123;</span><br><span class="line">t.Logf(&quot;%[1]c  %[1]x&quot;,value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// strings函数</span><br><span class="line">func TestStringFn(t *testing.T)  &#123;</span><br><span class="line">s := &quot;A,B,C&quot;</span><br><span class="line">parts := strings.Split(s,&quot;,&quot;)</span><br><span class="line">for _,part := range parts&#123;</span><br><span class="line">t.Logf(part)</span><br><span class="line">&#125;</span><br><span class="line">t.Log(strings.Join(parts,&quot;-&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// strconv 库函数</span><br><span class="line">func TestConv(t *testing.T)  &#123;</span><br><span class="line">s := strconv.Itoa(10)</span><br><span class="line">t.Log(&quot;str: &quot; + s)</span><br><span class="line">if i,err :=strconv.Atoi(&quot;25&quot;);err == nil&#123;</span><br><span class="line">t.Log(10 + i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> GoLang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go初试 一</title>
      <link href="/2019/11/23/Go%E5%88%9D%E8%AF%95%20%E4%B8%80/"/>
      <url>/2019/11/23/Go%E5%88%9D%E8%AF%95%20%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言入门尝试-一"><a href="#Go语言入门尝试-一" class="headerlink" title="Go语言入门尝试  一"></a>Go语言入门尝试  一</h1><ul><li>Go（又称 Golang）是 Google 的 Robert Griesemer，Rob Pike 及 Ken Thompson 开发的一种静态强类型、编译型语言。Go 语言语法与 C 相近，但功能上有：内存安全，GC（垃圾回收），结构形态及 CSP-style 并发计算。<h2 id="1-标准入门第一步：-HelloWorld"><a href="#1-标准入门第一步：-HelloWorld" class="headerlink" title="1.标准入门第一步： HelloWorld"></a>1.标准入门第一步： HelloWorld</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 1. package 必须是 main 对应 main方法</span><br><span class="line">// 2. import 引入依赖</span><br><span class="line">// 3. main 方法没有参数也没有退出值 全靠其他依赖完成</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">fmt.Print(&quot;hello world.&quot; + os.Args[1]);</span><br><span class="line">os.Exit(0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-测试方法与命名规范："><a href="#2-测试方法与命名规范：" class="headerlink" title="2.测试方法与命名规范："></a>2.测试方法与命名规范：</h2></li><li>以斐波那契数列为例</li><li>测试方法文件必须以 _test.go结尾，package不必是main</li><li>但是方法测试的方法必须是func TestXXX(t *testing.T)的命名</li><li>申请变量有三种方式赋值也有三种方式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package try_test</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line">// 变量</span><br><span class="line">func TestFibList(t *testing.T) &#123;</span><br><span class="line">// 直接声明变量</span><br><span class="line">//var a int = 1</span><br><span class="line">//var b int = 1</span><br><span class="line">// 申请多个变量</span><br><span class="line">//var(</span><br><span class="line">//a int = 1</span><br><span class="line">//b int = 1</span><br><span class="line">//)</span><br><span class="line">// 简写申请变量</span><br><span class="line">a := 1</span><br><span class="line">b := 1</span><br><span class="line">t.Log(a,&quot; &quot;)</span><br><span class="line">t.Log(b,&quot; &quot;)</span><br><span class="line">for i:=0;i&lt;5;i++&#123;</span><br><span class="line">t.Log(b,&quot; &quot;)</span><br><span class="line">tmp := a</span><br><span class="line">a = b</span><br><span class="line">b = tmp + a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 变量赋值</span><br><span class="line">func TestExchange(t *testing.T)  &#123;</span><br><span class="line">a:=1</span><br><span class="line">b:=2</span><br><span class="line"></span><br><span class="line">// 普通的交换变量</span><br><span class="line">//tmp := a</span><br><span class="line">//a = b</span><br><span class="line">//b = tmp</span><br><span class="line">//t.Log(a,b)</span><br><span class="line"></span><br><span class="line">// 多个变量赋值</span><br><span class="line">a,b = b,a</span><br><span class="line">t.Log(a,b)</span><br><span class="line">&#125;</span><br><span class="line">// 常量</span><br><span class="line">const(</span><br><span class="line">// iota 连续赋值</span><br><span class="line">Mondy = 1 + iota</span><br><span class="line">Tuesday</span><br><span class="line">Wednesday</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func TestConstantTry(t *testing.T)  &#123;</span><br><span class="line">t.Log(Mondy,Tuesday)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-变量类型："><a href="#3-变量类型：" class="headerlink" title="3.变量类型："></a>3.变量类型：</h2><ul><li>类型像C但是不支持隐性类型转换</li><li>支持指针但是不支持指针运算</li><li>字符串为空 == “”<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package ch3</span><br><span class="line"></span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">type MyInt int64        // 自定义类型</span><br><span class="line"></span><br><span class="line">// 数据类型不支持隐形转换</span><br><span class="line">func TestImplicit(t *testing.T)&#123;</span><br><span class="line">var a int = 1</span><br><span class="line">var b int64</span><br><span class="line">b = int64(a)</span><br><span class="line">var c MyInt</span><br><span class="line">c = MyInt(b)</span><br><span class="line">t.Log(a,b,c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 指针可用 但不支持运算</span><br><span class="line">func TestPoint(t *testing.T)  &#123;</span><br><span class="line">a := 1</span><br><span class="line">aPtr := &amp;a</span><br><span class="line">//aPtr = aPtr +1</span><br><span class="line">t.Log(a,aPtr)</span><br><span class="line">t.Logf(&quot;%T %T&quot;,a,aPtr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// String 为空用“”表示</span><br><span class="line">func TestString(t *testing.T)&#123;</span><br><span class="line">var s string</span><br><span class="line">t.Log(s)</span><br><span class="line">t.Log(len(s))</span><br><span class="line">if s == &quot;&quot;&#123;</span><br><span class="line">t.Log(&quot;s 为空&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-数组"><a href="#4-数组" class="headerlink" title="4.数组"></a>4.数组</h2><ul><li>数组的比较只限长度相同的数组</li><li>itoa 自加定义<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package ch4</span><br><span class="line"></span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">// 数组的比较</span><br><span class="line">func TestCompareArray(t *testing.T)  &#123;</span><br><span class="line">a:=[...] int&#123;1,2,3&#125;</span><br><span class="line">b:=[...] int&#123;1,1,3&#125;</span><br><span class="line">//c:=[...] int&#123;1,2,3,4&#125;</span><br><span class="line">d:=[...] int&#123;1,2,3&#125;</span><br><span class="line"></span><br><span class="line">t.Log(a==b)</span><br><span class="line">//t.Log(a==c)// 长度不同直接报错</span><br><span class="line">t.Log(a==d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// TestBitClear</span><br><span class="line">const (</span><br><span class="line">read = 1 &lt;&lt; iota</span><br><span class="line">write</span><br><span class="line">exec</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func TestBitClear(t *testing.T)&#123;</span><br><span class="line">a := 7  // 0111</span><br><span class="line">a = a &amp;^ read// 清除可读权限</span><br><span class="line">t.Log(a&amp;read == read,a&amp;write==write,a&amp;exec==exec)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-分支判断"><a href="#5-分支判断" class="headerlink" title="5.分支判断"></a>5.分支判断</h2><ul><li>if 语句与 多返回写法</li><li>多条件的 switch</li><li>使用switch 代替 复杂的 if<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package ch5</span><br><span class="line"></span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">// if 语句与 多返回</span><br><span class="line">func TestIfMultiSec(t *testing.T)  &#123;</span><br><span class="line">if a:=1 == 1; a&#123;</span><br><span class="line">t.Log(&quot;1==1&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 多返回在if中应用</span><br><span class="line">//if v,err := someFun(); err==nil&#123;</span><br><span class="line">//t.Log(&quot;success&quot;)</span><br><span class="line">//&#125;else&#123;</span><br><span class="line">//t.Log(&quot;error&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 多条件的 switch</span><br><span class="line">func TestSwitchMultiCase(t *testing.T)&#123;</span><br><span class="line">for i:=0;i&lt;5 ;i++  &#123;</span><br><span class="line">switch i &#123;</span><br><span class="line">case 0,2:t.Log(&quot;even&quot;)</span><br><span class="line">case 1,3:t.Log(&quot;odd&quot;)</span><br><span class="line">default:t.Log(&quot;it is not 0-3&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用switch 代替 复杂的 if</span><br><span class="line">func TestSwitchCaseCondition(t *testing.T)  &#123;</span><br><span class="line">for i:=0;i&lt;5 ;i++  &#123;</span><br><span class="line">switch &#123;</span><br><span class="line">case i%2==0:t.Log(&quot;even&quot;)</span><br><span class="line">case i%2==1:t.Log(&quot;odd&quot;)</span><br><span class="line">default:t.Log(&quot;unknow&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-循环条件"><a href="#6-循环条件" class="headerlink" title="6.循环条件"></a>6.循环条件</h2><ul><li>这个和其他语言都一样<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package ch5</span><br><span class="line"></span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">func TestLoop(t *testing.T)&#123;</span><br><span class="line">n:=0</span><br><span class="line">for n&lt;5&#123;</span><br><span class="line">t.Log(n)</span><br><span class="line">n++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> GoLang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> hello world </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDFS的Shell操作</title>
      <link href="/2019/11/20/HDFS%E7%9A%84Shell%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/11/20/HDFS%E7%9A%84Shell%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="查询-hdfs-的命令"><a href="#查询-hdfs-的命令" class="headerlink" title="查询  hdfs 的命令:"></a>查询  hdfs 的命令:</h1><ul><li>hadoop  fs  xxx</li></ul><h2 id="1-追加内容到hdfs中的文件"><a href="#1-追加内容到hdfs中的文件" class="headerlink" title="1.追加内容到hdfs中的文件"></a>1.追加内容到hdfs中的文件</h2><blockquote><p>hadoop fs -appendToFile 本地文件 hdfs中的文件</p></blockquote><h2 id="2-查看文件内容"><a href="#2-查看文件内容" class="headerlink" title="2.查看文件内容"></a>2.查看文件内容</h2><blockquote><p>hadoop fs -cat 文件</p></blockquote><h2 id="3-修改文件权限"><a href="#3-修改文件权限" class="headerlink" title="3.修改文件权限"></a>3.修改文件权限</h2><blockquote><p>hadoop fs -chmod 权限修改  对象文件</p></blockquote><h2 id="4-修改文件的所属用户和组"><a href="#4-修改文件的所属用户和组" class="headerlink" title="4.修改文件的所属用户和组"></a>4.修改文件的所属用户和组</h2><blockquote><p>hadoop fs -chown  用户名 组名 文件</p></blockquote><h2 id="5-上传本地文件到hdfs"><a href="#5-上传本地文件到hdfs" class="headerlink" title="5.上传本地文件到hdfs"></a>5.上传本地文件到hdfs</h2><blockquote><p>hadoop fs -put 本地文件 hdfs路径<br>hadoop fs -copyFromLocal 本地文件 hdfs路径</p></blockquote><h2 id="6-下载hdfs文件到本地"><a href="#6-下载hdfs文件到本地" class="headerlink" title="6.下载hdfs文件到本地"></a>6.下载hdfs文件到本地</h2><blockquote><p>hadoop fs -get hdfs文件 本地路径<br>hadoop fs -copyToLocal hdfs文件 本地路径</p></blockquote><h2 id="7-在hdfs中拷贝文件"><a href="#7-在hdfs中拷贝文件" class="headerlink" title="7.在hdfs中拷贝文件"></a>7.在hdfs中拷贝文件</h2><blockquote><p>hadoop fs -cp 目标 拷贝路径</p></blockquote><h2 id="8-查询磁盘使用量"><a href="#8-查询磁盘使用量" class="headerlink" title="8.查询磁盘使用量"></a>8.查询磁盘使用量</h2><blockquote><p>hadoop fs -df -h  路径</p></blockquote><h2 id="9-统计磁盘文件的大小"><a href="#9-统计磁盘文件的大小" class="headerlink" title="9.统计磁盘文件的大小"></a>9.统计磁盘文件的大小</h2><blockquote><p>hadoop fs -du -s -h 目标目录-</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><pre><code>hadoop fs -lshadoop fs -mvhadoop fs mkdirhadoop fs rm -r</code></pre>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDFS的配置和一些操作</title>
      <link href="/2019/11/20/HDFS%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/11/20/HDFS%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="1-返回hadoop集群的信息："><a href="#1-返回hadoop集群的信息：" class="headerlink" title="1.返回hadoop集群的信息："></a>1.返回hadoop集群的信息：</h2><p><code>hdfs dfsadmin -report</code></p><h2 id="2-返回可访问的端口："><a href="#2-返回可访问的端口：" class="headerlink" title="2.返回可访问的端口："></a>2.返回可访问的端口：</h2><p><code>netstat -ntlp</code></p><h2 id="3-hadoop的网页访问-："><a href="#3-hadoop的网页访问-：" class="headerlink" title="3.hadoop的网页访问 ："></a>3.hadoop的网页访问 ：</h2><p> <code>masterip + ：端口50070</code></p><h2 id="4-关闭节点："><a href="#4-关闭节点：" class="headerlink" title="4.关闭节点："></a>4.关闭节点：</h2><p><code>hadoop-daemon.sh stop namenode/datanode</code>  </p><h2 id="5-hadoop-etc-hadoop-下的slaves管理着datanode："><a href="#5-hadoop-etc-hadoop-下的slaves管理着datanode：" class="headerlink" title="5.hadoop/etc/hadoop 下的slaves管理着datanode："></a>5.hadoop/etc/hadoop 下的slaves管理着datanode：</h2><p><code>vim slaves</code></p><blockquote><p>填入所有 datanode名字（S1）</p></blockquote><h2 id="6-利用master管理所有子节点："><a href="#6-利用master管理所有子节点：" class="headerlink" title="6.利用master管理所有子节点："></a>6.利用master管理所有子节点：</h2><blockquote><p><code>start-dfs.sh</code> 启动所有节点</p></blockquote><blockquote><p><code>stop-dfs.sh</code> 关闭所有节点</p></blockquote><h2 id="7-免密登陆："><a href="#7-免密登陆：" class="headerlink" title="7.免密登陆："></a>7.免密登陆：</h2><blockquote><p>ssh-keygen -t rsa<br>cd /.ssh</p></blockquote><p> 一路回车 生成两个文件 一个root的私钥 ，一个公钥</p><blockquote><p>ssh-copy-id S1（子节点）</p></blockquote><p>将公钥给子节点，以后就不用给密码了</p><h2 id="8-hadoop-fs-ls（Linux的命令）-。。。。"><a href="#8-hadoop-fs-ls（Linux的命令）-。。。。" class="headerlink" title="8. hadoop fs  -ls（Linux的命令）  。。。。"></a>8. hadoop fs  -ls（Linux的命令）  。。。。</h2><p>其实是类似linux</p><blockquote><p>例如  <code>hadoop fs -put     ...</code><br>将。。。上传至hdfs系统</p></blockquote><h2 id="9-修改文件备份数量"><a href="#9-修改文件备份数量" class="headerlink" title="9.修改文件备份数量"></a>9.修改文件备份数量</h2><p>vim hdfs-site.xml<br>添加:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;3&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop集群搭建手册</title>
      <link href="/2019/11/20/Hadoop%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%89%8B%E5%86%8C/"/>
      <url>/2019/11/20/Hadoop%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Hadoop集群搭建手册"><a href="#Hadoop集群搭建手册" class="headerlink" title="Hadoop集群搭建手册"></a>Hadoop集群搭建手册</h1><h2 id="1-准备材料"><a href="#1-准备材料" class="headerlink" title="1.准备材料"></a>1.准备材料</h2><ul><li>centos7 虚拟机N台</li><li>xshell xftp</li><li>hadoop,jdk安装包</li></ul><h2 id="2-将Linux连接到客户端（本机）"><a href="#2-将Linux连接到客户端（本机）" class="headerlink" title="2.将Linux连接到客户端（本机）"></a>2.将Linux连接到客户端（本机）</h2><pre><code>修改网关： 本机为192.168.2.1  其他为101/102/103.。。。在虚拟机中选择host-only网络vim /etc/sysconfig/network&gt;&gt;&gt;NETWORKING=yes&gt;&gt;&gt;GATWAY=192.168.2.1 (本机ip)修改ipvim /etc/sysconfig/network-sripts/ifcfg-enp0s3  (linux网卡名字)&gt;&gt;&gt;TYPE=Ethernet&gt;&gt;&gt;IPADDR=192.168.20  (给linux分配的ip)&gt;&gt;&gt;NETMASK=255.255.255.0修改主机名 ；hostnamectl set-hostname  ....重启网络：service network restart测试是否修改成功：（注意关掉防火墙)ifconfigping 客户端ip</code></pre><h2 id="3-安装好一台linux："><a href="#3-安装好一台linux：" class="headerlink" title="3.安装好一台linux："></a>3.安装好一台linux：</h2><pre><code>装好xshell 利用ssh访问linux装好xftp  将本地下载的 Hadoop jdk 上传 linux安装 jdk：rpm -ivh 。。。rpm   （默认安装在/usr/java）用 java命令检查安装 Hadoop：tar -xvf 。。。tar.gzmv改名</code></pre><p>设置环境变量</p><blockquote><p>vim /etc/profile</p></blockquote><pre><code>export HADOOP_HOME=/usr/local/hadoopexport PATH=$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH</code></pre><p>让设置生效</p><pre><code>source /etc/profile</code></pre><p>设置Hadoop的JAVA_HOME</p><pre><code>cd /usr/local/hadoopvim etc/hadoop/hadoop-env.shexport JAVA_HOME=/usr/java/default</code></pre><h2 id="4-网络联通"><a href="#4-网络联通" class="headerlink" title="4.网络联通"></a>4.网络联通</h2><pre><code>全部关掉防火墙systemctl stop firewalldsystemctl disable firewalld查看防火墙状态firewall-cmd --state停止firewallsystemctl stop firewalld.service禁止firewall开机启动systemctl disable firewalld.service 互相ping测试是否联通分别进行 修改ip/ 修改主机名 / 重启网络 的操作</code></pre><h2 id="5-配置-usr-local-hadoop-etc-hadoop"><a href="#5-配置-usr-local-hadoop-etc-hadoop" class="headerlink" title="5.配置/usr/local/hadoop/etc/hadoop"></a>5.配置/usr/local/hadoop/etc/hadoop</h2><p>中心节点配置：</p><blockquote><p>vim core-site.xml</p></blockquote><pre><code>&lt;!-- 指定HADOOP所使用的文件系统schema（URI），HDFS的老大（NameNode）的地址 --&gt;&lt;property&gt;    &lt;name&gt;fs.defaultFS&lt;/name&gt;    &lt;value&gt;hdfs://master:9000&lt;/value&gt;&lt;/property&gt;&lt;!-- 指定hadoop运行时产生文件的存储目录 --&gt;&lt;property&gt;      &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;    &lt;value&gt;/usr/local/hadoop/tmp&lt;/value&gt;&lt;/property&gt;</code></pre><p> 修改备份数量</p><blockquote><p>vim hdfs-site.xml</p></blockquote><pre><code>&lt;!-- 指定HDFS副本的数量 --&gt;&lt;property&gt;    &lt;name&gt;dfs.replication&lt;/name&gt;    &lt;value&gt;1&lt;/value&gt;&lt;/property&gt; &lt;!-- 指Second namenode的启动位置 --&gt;&lt;property&gt;    &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;    &lt;value&gt;master:50090&lt;/value&gt;&lt;/property&gt;</code></pre><p>修改计算框架    </p><blockquote><p>vim mapred-site.xml</p></blockquote><pre><code>&lt;!-- 指定mr运行在yarn上 --&gt;&lt;property&gt;    &lt;name&gt;mapreduce.framework.name&lt;/name&gt;    &lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt;</code></pre><p>修改资源调用框架</p><blockquote><p>vim yarn-site.xml</p></blockquote><pre><code>&lt;!-- 指定YARN的老大（ResourceManager）的地址 --&gt;&lt;property&gt;        &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;        &lt;value&gt;master&lt;/value&gt;&lt;/property&gt;    &lt;!-- reducer获取数据的方式 --&gt;&lt;property&gt;        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;        &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt;</code></pre><h4 id="如果是完全分布式-将上面的做好的拷贝-修改ip-hostname即可。如果是伪分布式-就这样运行就好了"><a href="#如果是完全分布式-将上面的做好的拷贝-修改ip-hostname即可。如果是伪分布式-就这样运行就好了" class="headerlink" title="如果是完全分布式,将上面的做好的拷贝,修改ip hostname即可。如果是伪分布式,就这样运行就好了"></a>如果是完全分布式,将上面的做好的拷贝,修改ip hostname即可。如果是伪分布式,就这样运行就好了</h4><h2 id="6-启动hdfs"><a href="#6-启动hdfs" class="headerlink" title="6.启动hdfs"></a>6.启动hdfs</h2><pre><code>首先格式化hdfs   hdfs namenode -format将ip与名字对应vim /etc/hosts    192.168.2.20  master    ....    ....    ....master启动 namenode：    hadoop-daemon.sh start namenodejps  检查namenode是否启动vim slaves添加子节点信息    master    s1    ....slave启动 datanode：    hadoop-daemon.sh start datanodejps检查</code></pre><h2 id="错误指南"><a href="#错误指南" class="headerlink" title="错误指南"></a>错误指南</h2><pre><code>1.如果出现javahome问题          &gt;&gt;&gt; 配置javahome路径 vim hadoop-env.sh             /usr/java/default2.出现 -bash  hadoop  。。。not found 问题    &gt;&gt;&gt; 配置 vim /etc/profile增加:    export HADOOP_HOME=/usr/local/hadoop    export PATH=$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH3.修改完配置信息以后记得 source  /。。。4.多次格式化hdfs会导致 namenode与datanode的id不合  &gt;&gt; master启动不了datanode 进入hadoop的logs 下查看日志   &gt;&gt;  修改Version的 natanode 和 namenode 的clusterID一致</code></pre>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019蓝桥杯校赛总结</title>
      <link href="/2019/11/17/2019%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E8%B5%9B/"/>
      <url>/2019/11/17/2019%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="2019蓝桥杯校赛总结"><a href="#2019蓝桥杯校赛总结" class="headerlink" title="2019蓝桥杯校赛总结"></a>2019蓝桥杯校赛总结</h2><h4 id="1-2-计算器计算内存-手动忽略"><a href="#1-2-计算器计算内存-手动忽略" class="headerlink" title="1 - 2 计算器计算内存(手动忽略)"></a>1 - 2 计算器计算内存(手动忽略)</h4><h4 id="3-统计1-2019中带’9’的数字有多少个"><a href="#3-统计1-2019中带’9’的数字有多少个" class="headerlink" title="3.统计1-2019中带’9’的数字有多少个"></a>3.统计1-2019中带’9’的数字有多少个</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class C &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int res = 0;</span><br><span class="line">for(int i=1;i&lt;=2019;i++)&#123;</span><br><span class="line">if(func(String.valueOf(i))) res++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line">public static boolean func(String n) &#123;</span><br><span class="line">for(char c:n.toCharArray())&#123;</span><br><span class="line">if(c == &apos;9&apos;) return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>思路很简单,要么用字符串要么用取模判断是不是含有’9’</li></ul><h4 id="4-统计8-8的图里有多少种走对角线的方式"><a href="#4-统计8-8的图里有多少种走对角线的方式" class="headerlink" title="4.统计8*8的图里有多少种走对角线的方式"></a>4.统计8*8的图里有多少种走对角线的方式</h4><p>这个题有点东西是在给了很多限制，其实最后发现都是没啥用的，加不加也是那么多 (只能往右或者往下走) 直接dfs即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class D &#123;</span><br><span class="line">static int res = 0;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">dfs(0,0,0);</span><br><span class="line">System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line">public static void dfs(int i,int j,int count)&#123;</span><br><span class="line">if(i&lt;0||i&gt;=8||j&lt;0||j&gt;=8||count&gt;14) return;</span><br><span class="line">if(i==7&amp;&amp;j==7&amp;&amp;count==14)&#123;</span><br><span class="line">res++;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">dfs(i+1,j,count+1);</span><br><span class="line">dfs(i,j+1,count+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-和第三题有点类似-只不过是求1-n直接有多少-由不同数字组成的数字"><a href="#5-和第三题有点类似-只不过是求1-n直接有多少-由不同数字组成的数字" class="headerlink" title="5.和第三题有点类似,只不过是求1-n直接有多少(由不同数字组成的数字)"></a>5.和第三题有点类似,只不过是求1-n直接有多少(由不同数字组成的数字)</h4><ul><li>多加一个vis数组判断该数,是否在这个数字里出现过 复杂度应该是(数字的位数*n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class E &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Scanner sc = new Scanner(System.in);</span><br><span class="line">int n = sc.nextInt();</span><br><span class="line">int res = n;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">if(func(i)) res--;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line">public static boolean func(int num)&#123;</span><br><span class="line">boolean[] vis = new boolean[11];//这里有点费空间</span><br><span class="line">while(num != 0)&#123;</span><br><span class="line">int n = num%10;</span><br><span class="line">if(vis[n]) return true;</span><br><span class="line">else vis[n] = true;</span><br><span class="line">num /= 10;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-求最长上升子序列的长度"><a href="#6-求最长上升子序列的长度" class="headerlink" title="6.求最长上升子序列的长度"></a>6.求最长上升子序列的长度</h4><ul><li>直接遍历 (n的时间复杂度) 统计最长的序列长度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class F &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Scanner sc = new Scanner(System.in);</span><br><span class="line">int n = sc.nextInt();</span><br><span class="line">int[] nums = new int[n+1];</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">nums[i] = sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">int max = 1;</span><br><span class="line">int len = 1;</span><br><span class="line">int num = nums[0];</span><br><span class="line">for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">if(num&lt;nums[i]) len++;</span><br><span class="line">else len = 1;</span><br><span class="line">num = nums[i];</span><br><span class="line">if(len &gt; max ) max = len;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(max);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-本来是一道送分题-求逆序对"><a href="#7-本来是一道送分题-求逆序对" class="headerlink" title="7.本来是一道送分题,求逆序对"></a>7.本来是一道送分题,求逆序对</h4><ul><li>写过的题，结果活生生会被自己玩成了丢分题，思路很简单直接两层for暴力也能过，但是使用归并排序理论上是能过10w的测试集的。关键一步没写出来，难受，不想说话…..<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class G &#123;</span><br><span class="line">static int res = 0;</span><br><span class="line">static int[] nums;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Scanner sc = new Scanner(System.in);</span><br><span class="line">int n = sc.nextInt();</span><br><span class="line">nums = new int[n+1];</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">nums[i] = sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">merge_sort(nums,0,n-1);</span><br><span class="line">System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void merge_sort(int[] nums,int l,int r)&#123;</span><br><span class="line">if(l&gt;=r) return;</span><br><span class="line">int mid = l+r&gt;&gt;1;</span><br><span class="line">merge_sort(nums,l,mid);</span><br><span class="line">merge_sort(nums,mid+1,r);</span><br><span class="line">int[] tmp = new int[r-l+1];</span><br><span class="line">int k=0,left=l,right=mid+1;</span><br><span class="line">while(left&lt;=mid &amp;&amp; right&lt;=r)&#123;</span><br><span class="line">if(nums[left]&lt;=nums[right]) tmp[k++] = nums[left++];</span><br><span class="line">else &#123;</span><br><span class="line">tmp[k++] = nums[right++];</span><br><span class="line">res+=mid-left+1;            // 核心: 逆序对 应该是后面的数去前面的路程之和</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while(left&lt;=mid)&#123;</span><br><span class="line">tmp[k++] = nums[left++];</span><br><span class="line">&#125;</span><br><span class="line">while(right&lt;=r) tmp[k++] = nums[right++];</span><br><span class="line">for(int n:tmp) nums[l++] = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-求1-n之间取n个数且满足奇数位大于前一项-偶数位小于前一项"><a href="#8-求1-n之间取n个数且满足奇数位大于前一项-偶数位小于前一项" class="headerlink" title="8.求1-n之间取n个数且满足奇数位大于前一项,偶数位小于前一项"></a>8.求1-n之间取n个数且满足奇数位大于前一项,偶数位小于前一项</h4><ul><li>相当标准的搜索,但是好像拿不了多少分</li><li>思路: 第一个数随便取,后面的按奇偶位分策略搜索<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class H &#123;</span><br><span class="line">static int res = 0;</span><br><span class="line">static int n,m;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Scanner sc = new Scanner(System.in);</span><br><span class="line">m = sc.nextInt();</span><br><span class="line">n = sc.nextInt();</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">dfs(2,i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void dfs(int index,int pre)&#123;</span><br><span class="line">if(index == m+1)&#123;</span><br><span class="line">res++;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if(index % 2 == 0)&#123;</span><br><span class="line">for(int i=1;i&lt;pre;i++)&#123;</span><br><span class="line">dfs(index+1,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">for(int i=pre+1;i&lt;=n;i++)&#123;</span><br><span class="line">dfs(index+1,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="9-加上步长-求最短路径"><a href="#9-加上步长-求最短路径" class="headerlink" title="9.加上步长,求最短路径"></a>9.加上步长,求最短路径</h4><ul><li>也是dfs搜索最短路径,不过是搜索的路线有所限制,必须是满足路径之长小于步长(使用dp数组保存该点的最短路径,用空间换时间)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class I &#123;</span><br><span class="line">static boolean[][] vis;</span><br><span class="line">static int[][] dp;</span><br><span class="line">static int n,m;</span><br><span class="line">static double size; </span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Scanner sc = new Scanner(System.in);</span><br><span class="line">n = sc.nextInt();</span><br><span class="line">m = sc.nextInt();</span><br><span class="line">size = sc.nextDouble();</span><br><span class="line">vis = new boolean[n+1][m+1];</span><br><span class="line">dp = new int[n+1][m+1];</span><br><span class="line">System.out.println(dfs(1,1));</span><br><span class="line">&#125;</span><br><span class="line">public static int dfs(int i,int j)&#123;</span><br><span class="line">if(i==n&amp;&amp;j==m) return 0;</span><br><span class="line">if(dp[i][j] != 0) return dp[i][j];</span><br><span class="line">int min = Integer.MAX_VALUE;</span><br><span class="line">for(int x=0;x&lt;=n-i;x++)&#123;        // 搜索策略</span><br><span class="line">for(int y=0;y&lt;=m-j;y++)&#123;</span><br><span class="line">if(Math.sqrt((x*x) + (y*y)) &gt; size) break;</span><br><span class="line">if(!vis[i+x][j+y]) &#123;</span><br><span class="line">vis[i+x][j+y] = true;</span><br><span class="line">min = Math.min(min, dfs(i+x,j+y));</span><br><span class="line">vis[i+x][j+y] = false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[i][j] = min+1;       // 保存最短路径</span><br><span class="line">return min + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>但是好像还是过不了1000*1000的矩阵</p><h4 id="10-按原顺序输出前n大的数字"><a href="#10-按原顺序输出前n大的数字" class="headerlink" title="10.按原顺序输出前n大的数字"></a>10.按原顺序输出前n大的数字</h4><ul><li>前n大可以直接sort或者用优先队列</li><li>后面按顺序输出,可以用map记录前n大的数据,再回原数组中按位置输出</li><li>使用map可以用key记录数字,value记录出现次数,处理具有重复数据的情况<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class J &#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Scanner sc = new Scanner(System.in);</span><br><span class="line">int n = sc.nextInt();</span><br><span class="line">int m = sc.nextInt();</span><br><span class="line">int[] nums = new int[n+1];</span><br><span class="line">PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;(m);</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">int num = sc.nextInt();</span><br><span class="line">nums[i] = num;</span><br><span class="line">if(q.size() &lt;m) q.add(num);</span><br><span class="line">else if(q.peek() &lt; num)&#123;</span><br><span class="line">q.poll();</span><br><span class="line">q.add(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">int key = q.poll();</span><br><span class="line">if(map.containsKey(key))&#123;</span><br><span class="line">map.put(key,map.get(key)+1);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">map.put(key,1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">if(map.containsKey(nums[i]))&#123;</span><br><span class="line">System.out.print(nums[i] + &quot; &quot;);</span><br><span class="line">if(map.get(nums[i]) == 1) map.remove(nums[i]);</span><br><span class="line">else map.put(nums[i], map.get(nums[i])-1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>O(nlogn)的复杂度,应该能过,只是最后太着急,忘了加上判断,value为0时删除该元素….</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p> DFS用的很多，但是剪枝没写好，只能拿部分分。<br> 失误太多，会的没写出来，反而浪费大把时间。希望能过校赛，给个补救的机会。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DFS </tag>
            
            <tag> 排序算法 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> 竞赛 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序模板</title>
      <link href="/2019/11/16/%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF/"/>
      <url>/2019/11/16/%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul><li>利用分治，选择一个标兵使左右区间分别满足&lt;=和&gt;=标兵，递归子区间直到区间长度为1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void quick_sort(int[] nums, int l, int r) &#123;</span><br><span class="line">if(l&gt;=r) return;</span><br><span class="line">int m = nums[l+r&gt;&gt;1],left = l-1,right = r+1;  //注意此处的标兵取值 必须与下面递归的标兵相反 l - right</span><br><span class="line">while (left&lt;right)&#123;</span><br><span class="line">do left++; while (nums[left] &lt; m);</span><br><span class="line">do right--; while (nums[right] &gt; m);</span><br><span class="line">if(left&lt;right) &#123;</span><br><span class="line">int tmp = nums[left];</span><br><span class="line">nums[left] = nums[right];</span><br><span class="line">nums[right] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">quick_sort(nums,l,right);</span><br><span class="line">quick_sort(nums,right+1, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>持续优化：1.类似荷兰旗问题，当所求值与标兵相同时 不参与下一次递归<br>  2.随机标兵 表现会比固定标兵的效果好</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ul><li>也是分治，先递归，再合并。每次递归二分直到区间长度为1，然后和并返回有序数组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void merge_sort(int[] nums,int l,int r)&#123;</span><br><span class="line">    if(l&gt;=r) return;</span><br><span class="line">    int mid = l+r&gt;&gt;1;</span><br><span class="line">    merge_sort(nums,l,mid);</span><br><span class="line">    merge_sort(nums,mid+1,r);</span><br><span class="line">    int[] tmp = new int[r-l+1];</span><br><span class="line">    int k=0,left=l,right=mid+1;</span><br><span class="line">    while(left&lt;=mid &amp;&amp; right&lt;=r)&#123;</span><br><span class="line">        if(nums[left]&lt;nums[right]) tmp[k++] = nums[left++];</span><br><span class="line">        else tmp[k++] = nums[right++];</span><br><span class="line">    &#125;</span><br><span class="line">    while(left&lt;=mid) tmp[k++] = nums[left++];</span><br><span class="line">    while(right&lt;=r) tmp[k++] = nums[right++];</span><br><span class="line">    for(int n:tmp) nums[l++] = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快排重在切分区间，归并重在合并区间"><a href="#快排重在切分区间，归并重在合并区间" class="headerlink" title="快排重在切分区间，归并重在合并区间"></a>快排重在切分区间，归并重在合并区间</h4><h2 id="java中的复合排序"><a href="#java中的复合排序" class="headerlink" title="java中的复合排序"></a>java中的复合排序</h2><ul><li>对新建的结构体使用继承 Comparable接口 实习排序对比</li><li>对于普通的对比，使用 new Comparator类</li><li>对于复合对比 使用多层if-else嵌套</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.List;</span><br><span class="line">// 对结构体排序</span><br><span class="line">class Node implements Comparable&lt;Node&gt;&#123;</span><br><span class="line">int x;</span><br><span class="line">int y;</span><br><span class="line">public Node(int x, int y) &#123;</span><br><span class="line">this.x = x;</span><br><span class="line">this.y = y;</span><br><span class="line">&#125;</span><br><span class="line">// 先按 x 排序 再按 y排序</span><br><span class="line">@Override</span><br><span class="line">public int compareTo(Node other) &#123;</span><br><span class="line">if(other.x &gt; this.x) return 1;</span><br><span class="line">else if(other.x &lt; this.x) return -1;</span><br><span class="line">else &#123;</span><br><span class="line">return other.y - this.y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class NodeSort &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">List&lt;Node&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.sort(new Comparator&lt;Node&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public int compare(Node o1, Node o2) &#123;</span><br><span class="line">return o1.x-o2.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java中的优先队列（堆排序）"><a href="#java中的优先队列（堆排序）" class="headerlink" title="java中的优先队列（堆排序）"></a>java中的优先队列（堆排序）</h2><ul><li>堆排序默认维护n大小的最值（默认最大值 小顶堆）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">public class heapSort &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    int[] arr = &#123;1,5,3,2,7,6,4,9,8&#125;;</span><br><span class="line">    int k = 3;      // 队的size</span><br><span class="line">    PriorityQueue&lt;Integer&gt; q1 = new PriorityQueue&lt;&gt;(k);   // 维护小顶堆</span><br><span class="line">    PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;(k, new Comparator&lt;Integer&gt;() &#123;   // 维护大顶堆</span><br><span class="line">      @Override</span><br><span class="line">      public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">        return o2-o1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    for (int i = 0; i &lt;9 ; i++) &#123;</span><br><span class="line">      if(q.size() &lt; k) q.add(arr[i]);</span><br><span class="line">      else if(arr[i] &lt; q.peek())&#123;</span><br><span class="line">        q.poll();</span><br><span class="line">        q.add(arr[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt;k ; i++) &#123;</span><br><span class="line">      System.out.println(q.poll());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
